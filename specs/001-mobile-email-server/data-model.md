# Data Model: Modular Email Server

**Feature**: 001-mobile-email-server  
**Date**: 2026-01-22  
**Phase**: 1 - Design

## Overview

MailRaven follows Clean Architecture (Ports and Adapters). This document defines:
1. **Domain Entities**: Pure Go structs representing core business concepts
2. **Port Interfaces**: Contracts for storage, search, and blob operations
3. **Storage Schema**: SQLite tables implementing the ports

## Domain Entities

Domain entities are pure Go structs with no external dependencies (no database tags, no JSON tags). They represent core email concepts.

### Email Message

```go
package domain

import "time"

// Message represents an email message with metadata and authentication results
type Message struct {
    ID           string    // Unique message ID (generated, e.g., UUID)
    MessageID    string    // Email Message-ID header value
    Sender       string    // MAIL FROM address
    Recipient    string    // RCPT TO address (single recipient for MVP)
    Subject      string    // Email subject line
    Snippet      string    // First 200 chars of body for list view
    BodyPath     string    // Path to compressed body file in blob store
    ReadState    bool      // Has user read this message?
    ReceivedAt   time.Time // When server accepted the message
    
    // Email authentication results (from SPF/DKIM/DMARC validation)
    SPFResult    string    // "pass", "fail", "softfail", "neutral", "none"
    DKIMResult   string    // "pass", "fail", "none"
    DMARCResult  string    // "pass", "fail", "none"
    DMARCPolicy  string    // "none", "quarantine", "reject"
}
```

### User Account

```go
// User represents a mailbox owner with authentication credentials
type User struct {
    Email        string    // Email address (primary key)
    PasswordHash string    // Bcrypt hash of password
    CreatedAt    time.Time // Account creation timestamp
    LastLoginAt  time.Time // Most recent successful login
}
```

### Message Body

```go
// MessageBody represents the full raw email content stored in blob storage
type MessageBody struct {
    MessageID      string // References Message.ID
    RawContent     []byte // Full MIME message (after decompression)
    CompressedSize int64  // Size of compressed file
    OriginalSize   int64  // Size before compression
}
```

### Authentication Token

```go
// AuthToken represents a JWT token for API authentication
type AuthToken struct {
    TokenString string    // JWT token string
    UserEmail   string    // Email address of authenticated user
    IssuedAt    time.Time // When token was issued
    ExpiresAt   time.Time // When token expires (7 days from issue)
}
```

### SMTP Session

```go
// SMTPSession represents temporary state for an active SMTP connection
// (Not persisted, exists only during connection lifetime)
type SMTPSession struct {
    SessionID   string    // Unique session identifier (for logging)
    RemoteIP    string    // Client IP address
    Sender      string    // MAIL FROM value
    Recipients  []string  // RCPT TO addresses
    ConnectedAt time.Time // Connection start time
    BytesRecv   int64     // Bytes received in DATA command
}
```

### DNS Record (Configuration)

```go
// DNSRecord represents a DNS configuration record for the mail domain
// Generated by quickstart command
type DNSRecord struct {
    Type     string // "MX", "TXT" (for SPF/DKIM/DMARC)
    Name     string // DNS record name (e.g., "@", "_dmarc", "mail._domainkey")
    Value    string // DNS record value
    TTL      int    // Time to live in seconds
    Priority int    // MX record priority (10 for primary)
}
```

## Port Interfaces

Ports define contracts for external dependencies. Adapters implement these interfaces.

### EmailRepository

```go
package ports

import (
    "context"
    "github.com/mailraven/internal/core/domain"
)

// EmailRepository defines storage operations for email messages
type EmailRepository interface {
    // Save stores a new message (atomic with blob storage)
    // Returns error if message already exists or storage fails
    Save(ctx context.Context, msg *domain.Message) error
    
    // FindByID retrieves a single message by ID
    // Returns ErrNotFound if message doesn't exist
    FindByID(ctx context.Context, id string) (*domain.Message, error)
    
    // FindByUser retrieves paginated messages for a user
    // Results ordered by ReceivedAt DESC (newest first)
    // Returns empty slice if no messages match
    FindByUser(ctx context.Context, email string, limit, offset int) ([]*domain.Message, error)
    
    // UpdateReadState marks a message as read or unread
    // Returns ErrNotFound if message doesn't exist
    UpdateReadState(ctx context.Context, id string, read bool) error
    
    // CountByUser returns total message count for a user
    CountByUser(ctx context.Context, email string) (int, error)
    
    // FindSince retrieves messages received after a timestamp (delta sync)
    FindSince(ctx context.Context, email string, since time.Time, limit int) ([]*domain.Message, error)
}
```

### UserRepository

```go
// UserRepository defines storage operations for user accounts
type UserRepository interface {
    // Create creates a new user with hashed password
    // Returns ErrAlreadyExists if email already registered
    Create(ctx context.Context, user *domain.User) error
    
    // FindByEmail retrieves user by email address
    // Returns ErrNotFound if user doesn't exist
    FindByEmail(ctx context.Context, email string) (*domain.User, error)
    
    // Authenticate verifies email/password and returns user
    // Returns ErrInvalidCredentials if auth fails
    Authenticate(ctx context.Context, email, password string) (*domain.User, error)
    
    // UpdateLastLogin updates the LastLoginAt timestamp
    UpdateLastLogin(ctx context.Context, email string) error
}
```

### BlobStore

```go
// BlobStore defines storage operations for large binary objects (email bodies)
type BlobStore interface {
    // Write stores compressed message body and returns storage path
    // Compression is transparent to caller
    Write(ctx context.Context, messageID string, content []byte) (path string, err error)
    
    // Read retrieves and decompresses message body
    // Returns ErrNotFound if path doesn't exist
    Read(ctx context.Context, path string) ([]byte, error)
    
    // Delete removes a blob from storage
    Delete(ctx context.Context, path string) error
    
    // Verify checks if blob exists and is readable
    Verify(ctx context.Context, path string) error
}
```

### SearchIndex

```go
// SearchIndex defines full-text search operations for messages
type SearchIndex interface {
    // Index adds or updates a message in the search index
    Index(ctx context.Context, msg *domain.Message, bodyText string) error
    
    // Search performs full-text query and returns ranked results
    // Query syntax: plain text or operators like "from:sender@example.com"
    // Results ordered by relevance (BM25 ranking)
    Search(ctx context.Context, userEmail, query string, limit, offset int) ([]*domain.Message, error)
    
    // Delete removes a message from the index
    Delete(ctx context.Context, messageID string) error
}
```

### Common Errors

```go
package ports

import "errors"

var (
    ErrNotFound           = errors.New("resource not found")
    ErrAlreadyExists      = errors.New("resource already exists")
    ErrInvalidCredentials = errors.New("invalid email or password")
    ErrStorageFailure     = errors.New("storage operation failed")
)
```

## SQLite Storage Schema

SQLite adapter implements `EmailRepository`, `UserRepository`, and `SearchIndex`.

### Users Table

```sql
CREATE TABLE users (
    email TEXT PRIMARY KEY,
    password_hash TEXT NOT NULL,
    created_at INTEGER NOT NULL,  -- Unix timestamp
    last_login_at INTEGER NOT NULL
);

CREATE INDEX idx_users_last_login ON users(last_login_at DESC);
```

### Messages Table

```sql
CREATE TABLE messages (
    id TEXT PRIMARY KEY,
    message_id TEXT NOT NULL,          -- Email Message-ID header
    sender TEXT NOT NULL,
    recipient TEXT NOT NULL,           -- References users(email)
    subject TEXT NOT NULL,
    snippet TEXT NOT NULL,
    body_path TEXT NOT NULL,           -- Path in blob store
    read_state INTEGER NOT NULL,       -- 0 = unread, 1 = read
    received_at INTEGER NOT NULL,      -- Unix timestamp
    
    spf_result TEXT NOT NULL,          -- "pass", "fail", "softfail", "neutral", "none"
    dkim_result TEXT NOT NULL,         -- "pass", "fail", "none"
    dmarc_result TEXT NOT NULL,        -- "pass", "fail", "none"
    dmarc_policy TEXT NOT NULL,        -- "none", "quarantine", "reject"
    
    FOREIGN KEY (recipient) REFERENCES users(email) ON DELETE CASCADE
);

-- Performance indexes
CREATE INDEX idx_messages_recipient ON messages(recipient, received_at DESC);
CREATE INDEX idx_messages_received_at ON messages(received_at DESC);
CREATE INDEX idx_messages_sender ON messages(sender);
CREATE INDEX idx_messages_read_state ON messages(recipient, read_state);
CREATE UNIQUE INDEX idx_messages_message_id ON messages(message_id);
```

### Full-Text Search (FTS5)

```sql
-- Virtual table for full-text search
CREATE VIRTUAL TABLE messages_fts USING fts5(
    message_id UNINDEXED,              -- Foreign key, not searchable
    recipient UNINDEXED,               -- Filter field, not searchable
    sender,                            -- Searchable
    subject,                           -- Searchable
    body_text,                         -- Searchable (first 10KB of plaintext)
    tokenize='porter unicode61'       -- Porter stemming + Unicode tokenization
);

-- Keep FTS in sync with messages table
-- Note: Triggers add slight overhead but ensure consistency
CREATE TRIGGER messages_fts_insert AFTER INSERT ON messages BEGIN
    INSERT INTO messages_fts(message_id, recipient, sender, subject, body_text)
    VALUES (NEW.id, NEW.recipient, NEW.sender, NEW.subject, '');
    -- Body text populated asynchronously by search indexer
END;

CREATE TRIGGER messages_fts_delete AFTER DELETE ON messages BEGIN
    DELETE FROM messages_fts WHERE message_id = OLD.id;
END;
```

### Configuration & Pragmas

```sql
-- Enable Write-Ahead Logging for better concurrent performance
PRAGMA journal_mode=WAL;

-- Full durability: fsync on every commit (required by constitution)
PRAGMA synchronous=FULL;

-- Foreign key enforcement
PRAGMA foreign_keys=ON;

-- Check database integrity on startup
PRAGMA integrity_check;
```

## Blob Storage Structure

File system structure for message bodies:

```
/var/lib/mailraven/messages/
├── 2026/
│   ├── 01/
│   │   ├── 22/
│   │   │   ├── <message-id>.eml.gz  # Gzip-compressed MIME message
│   │   │   ├── <message-id>.eml.gz
│   │   │   └── ...
```

**File Naming**: `<message-id>.eml.gz` (UUID-based message ID + .eml.gz extension)
**Date-Based Sharding**: Messages organized by year/month/day for easier backup/archival
**Compression**: Gzip compression (typically 50-70% space savings for email)

## Relationships

```
User (1) ──────< (N) Message
             recipient

Message (1) ─────< (1) MessageBody
              via body_path

Message (1) ─────< (1) messages_fts
              via message_id
```

## Data Flow: Saving a Message

1. **SMTP Adapter** receives email, validates SPF/DKIM/DMARC
2. **SMTP Adapter** calls `EmailRepository.Save()` with domain.Message
3. **SQLite Adapter** starts transaction:
   - Inserts row into `messages` table
   - Calls `BlobStore.Write()` to save compressed body
   - Commits transaction with fsync
4. **SQLite Adapter** calls `SearchIndex.Index()` to update FTS5
5. **SMTP Adapter** sends "250 OK" to client (only after step 3 succeeds)

## Data Flow: Mobile API List Messages

1. **HTTP Adapter** receives GET `/v1/messages?limit=20&offset=0`
2. **HTTP Adapter** validates JWT, extracts user email
3. **HTTP Adapter** calls `EmailRepository.FindByUser(email, 20, 0)`
4. **SQLite Adapter** queries messages table with pagination
5. **HTTP Adapter** serializes domain.Message to JSON, returns response

## Data Flow: Mobile API Search

1. **HTTP Adapter** receives GET `/v1/messages/search?q=invoice&limit=20`
2. **HTTP Adapter** validates JWT, extracts user email
3. **HTTP Adapter** calls `SearchIndex.Search(email, "invoice", 20, 0)`
4. **SQLite Adapter** queries FTS5 table with relevance ranking
5. **HTTP Adapter** returns ranked results as JSON

## Validation Rules

### Message Validation
- `ID`: Non-empty UUID string
- `Sender`: Valid email address (RFC 5322)
- `Recipient`: Valid email address, must exist in users table
- `Subject`: Max 998 characters (RFC 5321 line length limit)
- `Snippet`: Exactly 200 characters (or less if body shorter)
- `BodyPath`: Non-empty, file must exist in blob store
- `SPFResult`, `DKIMResult`, `DMARCResult`: Enum values only
- `ReceivedAt`: Not in future

### User Validation
- `Email`: Valid email address, max 254 characters
- `PasswordHash`: Non-empty bcrypt hash (60 characters)
- `CreatedAt`, `LastLoginAt`: Valid timestamps

### Search Query Validation
- `query`: Max 1000 characters, sanitized for FTS5 MATCH syntax
- `limit`: 1-1000 (enforce max page size)
- `offset`: >= 0

## Migration Strategy

### Current Implementation (MVP)
- SQLite for `EmailRepository` and `UserRepository`
- File system for `BlobStore`
- SQLite FTS5 for `SearchIndex`

### Future Migration Path (HA/Scale)
1. **Storage Layer**: Swap SQLite adapter for Postgres adapter
   - Same `EmailRepository` interface, different implementation
   - Schema translates directly (SQLite → PostgreSQL types)
   - Blob storage migrates to S3-compatible API (`BlobStore` interface unchanged)

2. **Search Layer**: Swap FTS5 adapter for Elasticsearch adapter
   - Same `SearchIndex` interface, different implementation
   - FTS5 → Elasticsearch index migration tool
   - BM25 ranking translates directly

3. **Zero Code Changes**: Core domain and HTTP/SMTP adapters unaffected
   - Dependency injection swaps concrete implementations at startup
   - Configuration file selects active adapters

## Appendix: Example Data

### Example Message

```go
msg := &domain.Message{
    ID:          "550e8400-e29b-41d4-a716-446655440000",
    MessageID:   "<abc123@sender.example.com>",
    Sender:      "billing@sender.example.com",
    Recipient:   "user@example.com",
    Subject:     "Invoice #12345 for January 2026",
    Snippet:     "Thank you for your business. Your invoice for January is attached. Amount due: $150.00. Payment terms: Net 30. Please remit payment by February 21, 2026. If you have any questions, co...",
    BodyPath:    "2026/01/22/550e8400-e29b-41d4-a716-446655440000.eml.gz",
    ReadState:   false,
    ReceivedAt:  time.Now(),
    SPFResult:   "pass",
    DKIMResult:  "pass",
    DMARCResult: "pass",
    DMARCPolicy: "none",
}
```

### Example User

```go
user := &domain.User{
    Email:        "user@example.com",
    PasswordHash: "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy", // bcrypt
    CreatedAt:    time.Date(2026, 1, 15, 10, 0, 0, 0, time.UTC),
    LastLoginAt:  time.Date(2026, 1, 22, 8, 30, 0, 0, time.UTC),
}
```

### Example Search Query

```go
// User searches for "invoice" in their mailbox
results, err := searchIndex.Search(
    ctx,
    "user@example.com",  // user's email
    "invoice",           // search term
    20,                  // limit
    0,                   // offset
)
// Returns messages ranked by BM25 relevance
```
